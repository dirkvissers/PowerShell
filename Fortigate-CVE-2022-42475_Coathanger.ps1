#region Script Header Section

<#
Dirk Vissers:
Using the Powershell PoshSSH-module to recusively scan for files within the directories that might give IoCs for CVE-2022-42475 and COATHANGER-malware.

Part 0 Before we begin... let's get the bulk out of the way: generating an overview of Fortigate and it's folderstructures and it's contents.
Everything will be put into the $Logfile and all the filepaths will be put into $AllFiles, which will be used for filename- and hashmatching.

Part 1 will be for CVE-2022-42475 IoC's:

    - Stage 1: Logdesc="Application crashed" and msg="[...] application: sslvpnd,[...], Signal 11 received, Backtrace: [...]“
    - Stage 2: Debug Crash-logs
    - Stage 3: Suspicious filesystem entries
    - Stage 4: Find malicious connections FROM the Fortigate

Part 2 will be for COATHANGER IoC's:

    - Stage 1: Suspicious filesystem entries
    - Stage 2: Diagnose active TCP Socket List for external IP's and the process that is using it (including PID)
    - Stage 3: Analyse the processes for anomalies, with extra attention to PID's captured in Stage 2
    - Stage 4: Generate hashes and compare them to known list of hashed related to COATHANGER

#>
#endregion

#region Script Environment setup
$FilePath = ($MyInvocation.MyCommand.Source -split ($MyInvocation.MyCommand.Name))[0] + "Fortigate-CVE-2022-42475_Coathanger-$(Get-Date -Format "dd-MM-yyyy_HH-mm")"
$Logfile = $FilePath + "-log.log"
$Transcript = $FilePath + "-transcript.log"
$AllFiles = $FilePath + "-files.log"

Start-Transcript -Path $Transcript -IncludeInvocationHeader

if ($null -eq $Logfile) { Write-Error "No Logging path set. Exiting script..."; Stop-Transcript;exit }
else { Write-Host "LogFile set at $($Logfile)" -ForegroundColor Green }

Write-Host "Fortigate SSH Script for CVE-2022-42475 and Coathanger IoC's." -ForegroundColor Green
"Fortigate SSH Script for CVE-2022-42475 and Coathanger IoC's." | Out-File $Logfile -Append
Write-Host "Fetching CSV containing all known IoC hashes..." -ForegroundColor Green
"Fetching CSV containing all known IoC hashes..." | Out-File $Logfile -Append

$CsvFilePath = ($MyInvocation.MyCommand.Source -split ($MyInvocation.MyCommand.Name))[0] + "Coathanger-IoC-hashes.csv"
[bool]$CsvFetchFail = $false
$CsvHash = "130C90354412D4DC51C824D267695B4A962542AE0895BE4B369855ADA74D70E4"

# Do/Until loop containing Try/Catch statements to check if the CSV is valid. It will only import after succesful validation.
do {
    try {
        # Is it present?
        if ($true -eq (Test-Path $CsvFilePath)) {
            # Does the hash match the original?
            if ($CsvHash -eq (Get-FileHash -Algorithm SHA256 $CsvFilePath).Hash) {
                # Import file
                $AllHashes = Import-CSV $CsvFilePath -Delimiter ";" 
            }
            # If it doesn't match: throw error Hash.Doesnt.Match, to move current file to "currentfile.bak" and download from GitHub
            else { throw "Hash.Doesnt.Match" }
        }
        # Is it missing?
        elseif ($false -eq (Test-Path $CsvFilePath)) {
            # Download from GitHub
            $GitHubRaw = Invoke-WebRequest -Uri "https://raw.githubusercontent.com/dirkvissers/PowerShell/refs/heads/main/Coathanger-IoC-hashes.csv"
            # Containing CSV content
            $GitHubRawCsv = $GitHubRaw.Content
            # If there's no content, throw error Download.Failure, to set CsvFetchFail to True. Which exits script
            if ($null -eq $GitHubRaw.Content) { throw "Download.Failure" }
            # If there IS content, let's create a CSV file from it
            else {
                # Create CSV File
                Set-Content -Path $CsvFilePath -Value $GitHubRawCsv -Force
                # Does the hash match the original?
                if ($CsvHash -eq (Get-FileHash -Algorithm SHA256 $CsvFilePath).Hash) {
                    # Import CSV to variable
                    $AllHashes = Import-CSV $CsvFilePath -Delimiter ";"
                }
                # If it doesn't match: throw error Hash.Doesnt.Match, to move current file to "currentfile.bak" and download from GitHub
                else { throw "Hash.Doesnt.Match" }
            }
        }
    }

    catch {
        if ($PSItem.Exception.Message -eq "Download.Failure") { Write-Host "Failed to download CSV. Exiting script..." ; $CsvFetchFail -eq $true }
        elseif ($PSItem.Exception.Message -eq "Hash.Doesnt.Match") { Move-Item -Path $CsvFilePath -Destination ($CsvFilePath + ".bak") -Force }
    }
}until(($null -ne $AllHashes.MD5) -or ($CsvFetchFail -eq $true))

if ($true -eq $CsvFetchFail) { Stop-Transcript; exit}
else { Write-Host "Fetching CSV successful!" -ForegroundColor Green }

"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nFortigate SSH Script for CVE-2022-42475 and Coathanger IoC's." | Out-File $Logfile -Append
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nActivating Posh-SSH Powershell Module..." | Out-File $Logfile -Append

Write-Host `n"Activating Posh-SSH Powershell Module..." -ForegroundColor Green
try {
    if ($null -eq (Get-Module Posh-SSH)) { throw "Missing.Installed.Module" }
    elseif ($null -ne (Get-Module Posh-SSH)) { throw "Missing.Imported.Module" }
}
catch {
    # 1 Missing module Posh-SSH: Downloading, Installing and Importing the module
    if ($PSItem.Exception.Message -eq "Missing.Installed.Module") {
        Install-Module -Name Posh-SSH -Scope CurrentUser -Force -AllowClobber -WarningAction SilentlyContinue
        Import-Module -Name Posh-SSH -Force -WarningAction SilentlyContinue
    }
    # 2 Module is present, importing cmdlets
    elseif ($PSItem.Exception.Message -eq "Missing.Imported.Module") {
        Import-Module -Name Posh-SSH -Force -WarningAction SilentlyContinue
    }
}
#endregion

#region Setting up script SSH Sessions parameters
Write-Host "Gathering credential for current session..." -ForegroundColor Green
$CredsAreSomething = $false

do {
    $creds = Get-Credential
    
    try {
        if ($null -eq $creds) { throw "Invalid.Credentials" }
        elseif ("" -eq $creds.UserName) { throw "Invalid.Credentials" }
        elseif (" " -eq $creds.UserName) { throw "Invalid.Credentials" }
        else { $CredsAreSomething = $true }
    }
    catch {
        if ($PSItem.Exception.Message -eq "Invalid.Credentials") { Write-Error "No valid credentials were given. Try again..." }
    }

}until($true -eq $CredsAreSomething)

# Function for seeings if there's not forbidden characters in the IP
function CheckOctets{
    param($IpAddress)
    $regex = [regex] "\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b"
    $regex.Matches($IpAddress)
}

# Getting IP-Address input and keeping de loop alive until a valid IP has been given.
do { 
    $IP = 0
    try {
        $IPInput = Read-Host "Enter the IP-address of the Fortigate" -ErrorAction Stop
        if ( (CheckOctets -IpAddress $IPInput).Success -eq $true ) { $IP = $IPInput }
        elseif ( $null -eq (CheckOctets -IpAddress $IPInput).Success ) { throw "No.Valid.IP" }
    }
    catch {
        if ($PSItem.Exception.Message -eq "No.Valid.IP") {
        Write-Host "Invalid IP-address has been entered. Try again." -ForegroundColor Red
    }
}
}until($IP -ne 0)

# Quick check if it's alive
if((Get-ChildItem -Path Env:SystemRoot).Value -match "WINDOWS" -eq $true){$Ping = ping -n 4 $IP}
else{$Ping = ping -c 4 $IP}

try {
    if ($Ping | Select-String "100% loss", "Destination host unreachable", "General failure","100% packet loss") { throw "Ping.Failure" }
}
catch {
    if ($PSItem.Exception.Message -eq "Ping.Failure") {
        Write-Error "IP-address is not reachable"
    }
}

# Gather the SSH Port, no input equals port 22
do { 

    [int]$SSHPort = 0
    try {
        [int]$SSHPortInput = Read-Host "Enter the SSH Port that the Fortigate is listening on [default:22]" -ErrorAction Stop
        if ($SSHPortInput -eq 0) { [int]$SSHPort = 22 }
        elseif ($SSHPortInput -notin @([int]0..65535)) { throw "Not.A.Valid.Port" }
    }
    catch [System.Management.Automation.PSInvalidCastException] {
        Write-Host "Input contains forbidden characters. Exception message:" -ForegroundColor Red
        Write-Error $PSItem.Exception.Message
    }
    catch {
        if ($PSItem.Exception.Message -eq "Not.A.Valid.Port") {
            Write-Host "Port number out of bounds. Exception message:" -ForegroundColor Red
            Write-Error $PSItem.Exception.Message
        }
        else{Write-Error $PSItem.Exception.Message}
    }
}until($SSHPort -ne 0)
#endregion

#region Part 0 - Iterating through the folderstructure.
<#
Target:
Contents of every folders, subfolders and putting the results into a logfile.

Tools:
Powershell: Using SSH to get all the current contents of the Fortigate.
Using 3 functions and iterating through generated hashtables 3 times would get us to our folder-structure 'dead-end'.

All contents will be put into a logfile which we will use multiple times in this script.

FortiOS: Using fortinet system control (fnsysctl) ls-cmdlet with -la parameter for showing hidden files and folders.
#>

# Setting up the Part0Session SSH Session and Stream with a Try/Catch, until the CommandStream is ready to process cmdlets
do {
    try {
        if ($null -eq $Part0Session) { throw "No.Active.Session" }
        elseif ($true -ne $Part0Session.Connected) { throw "No.Active.Session" }
        elseif ($false -eq $LogStream.CanWrite) { throw "No.Active.Stream" }
        elseif($true -eq $LogStream.CanWrite){ Write-Host "SSH Streams are ready." -ForegroundColor Green }
    }
    catch {
        # Catch 1 for setting up a new session and a new CommandStream
        if ($PSItem.Exception.Message -eq "No.Active.Session") {
            Write-Host "Setting up SSH Session for Part 0" -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH Session for Part 0" | Out-File $Logfile -Append
            $Part0Session = New-SSHSession -ComputerName $IP -Credential $creds -AcceptKey -Port $SSHPort

            Write-Host "Setting up SSH CMDlet Stream..." -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Stream for Part 0..." | Out-File $Logfile -Append
            $LogStream = $Part0Session.Session.CreateShellStream("SSH-LOG-STREAM", 0, 0, 0, 0, 4096)
        }
        
        # Catch 2 for opening the CommandStream when there is none, or when property CanWrite is False
        elseif ($PSItem.Exception.Message -eq "No.Active.Stream") {
            Write-Host "Setting up SSH CMDlet Stream..." -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Stream for Part 0..." | Out-File $Logfile -Append
            $LogStream = $Part0Session.Session.CreateShellStream("SSH-LOG-STREAM", 0, 0, 0, 0, 4096)
        }
    }
}until($true -eq $LogStream.CanWrite)

function SearchForFiles($SearchList, $MainDirectory) {
    # Splitting the SSH Output string to select the last entry, which contains the name of the file/folder
    $SearchList | ForEach-Object {
        $LineArrayFiles = @($_ -split " " | Where-Object { $_ -ne "" })
        if ( ($LineArrayFiles[0] -notmatch "dr" ) -and ($LineArrayFiles[0] -notmatch "lr" ) -and ($LineArrayFiles[0] -notmatch "br" ) -and ($LineArrayFiles[0] -notmatch "cr" ) -and ( $LineArrayFiles[0] -notin ($null, "", " ") ) ) {
            # Filtering files and adding them to the array $RecursiveFileList for later scanning
            $LineArrayFilesFilteredDirectory = $LineArrayFiles[$LineArrayFiles.Count - 1]
            if ( ($LineArrayFilesFilteredDirectory -notmatch @("/.", "/..")) -and ($LineArrayFilesFilteredDirectory -notmatch "->") ) {
                # Need an exception for the root directory of the Fortigate, otherwise we would have //filename and that would break cmdlets later on                
                if ($MainDirectory -eq "/") { $MainDirectory + $LineArrayFilesFilteredDirectory >> $AllFiles }
                else { ($MainDirectory + "/" + $LineArrayFilesFilteredDirectory) >> $AllFiles } 
            }
        }
    }
}

function SearchForDirs($SearchList) {
    # Splitting the SSH Output string to select the last entry, which contains the name of the file/folder
    $SearchList | ForEach-Object {
        $LineArrayDirectories = @($_ -split " " | Where-Object { $_ -ne "" })
        # Filtering directories and adding them to the hashtable for later scanning
        if ($LineArrayDirectories[0] -match "dr") {
            $LineArrayFilteredDirectory = "/" + $LineArrayDirectories[$LineArrayDirectories.Count - 1]
            if ($LineArrayFilteredDirectory -notin @("/.", "/..")) { $LineArrayFilteredDirectory }
        }
    }
}

function GenerateRootArray {
    # Using the SearchForDirs to look for directories and putting the results-array into the $DirectoryHashtable
    $Stage0RootCommand = "fnsysctl ls -la /"
    $Part0Output = Invoke-SSHStreamShellCommand -ShellStream $LogStream -Command $Stage0RootCommand
    Set-Content $Logfile -Value $Stage0RootCommand
    $Part0Output | Out-File $Logfile -Append
    # Formatting output to search for files and adding these to an array for ease of use when searching through the filesystem and generating hashes
    SearchForFiles -MainDirectory "/" -SearchList $Part0Output
    # Generating a list of contents, formatting it and creating an array to put into the hashtable
    $DirectoryHashtable."/" = SearchForDirs -SearchList $Part0Output
}

function GenerateDirArray ($CurrentDirToAnalyze) {
    $Stage0DirCommand = "fnsysctl ls -la " + $CurrentDirToAnalyze
    $Part0DirArrayOutput = Invoke-SSHStreamShellCommand -ShellStream $LogStream -Command $Stage0DirCommand
    $Stage0DirCommand | Out-File $Logfile -Append
    $Part0DirArrayOutput | Out-File $Logfile -Append
    # Formatting output to search for files and adding these to an array for ease of use when searching through the filesystem and generating hashes
    SearchForFiles -MainDirectory $CurrentDirToAnalyze -SearchList $Part0DirArrayOutput
    # Generating a list of contents, formatting it and creating an array to put into the hashtable
    SearchForDirs -SearchList $Part0DirArrayOutput
}

$DirectoryHashtable = @{}
Write-Host "Generating the initial Root Directory Overview" -ForegroundColor Green
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nGenerating the initial Root Directory Overview" | Out-File $Logfile -Append

GenerateRootArray

# Hashtable run using Root Array Directory Hashtable
Write-Host "Generating Fortigate Root directory overview" -ForegroundColor Yellow

$DirectoryHashtableKeyLoop = $DirectoryHashtable.Keys
$DirectoryHashtableTarget1 = @{}

foreach ($HashKey in $DirectoryHashtableKeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtable.$HashKey) {
        if ($null -ne $Directory) {
            Write-Host "Scanning subdirectory $($Directory)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget1.$Directory = GenerateDirArray -CurrentDirToAnalyze $Directory
        }
    }
}

# Hashtable second run using previous target table $DirectoryHashtableTarget1
Write-Host "Generating Fortigate second level directory overview" -ForegroundColor Yellow
$DirectoryHashtableTarget1KeyLoop = $DirectoryHashtableTarget1.Keys
$DirectoryHashtableTarget2 = @{}

foreach ($HashKey in $DirectoryHashtableTarget1KeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtableTarget1.$HashKey) {
        if ($null -ne $Directory) {
            $SubDir = $HashKey + $Directory
            Write-Host "Scanning subdirectory $($SubDir)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget2.$SubDir = GenerateDirArray -CurrentDirToAnalyze $SubDir
        }
    }
}

# Hashtable third run using previous target table $DirectoryHashtableTarget2
Write-Host "Generating Fortigate third level directory overview" -ForegroundColor Yellow
$DirectoryHashtableTarget2KeyLoop = $DirectoryHashtableTarget2.Keys
$DirectoryHashtableTarget3 = @{}

foreach ($HashKey in $DirectoryHashtableTarget2KeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtableTarget3.$HashKey) {
        if ($null -ne $Directory) {
            $SubDir = $HashKey + $Directory
            Write-Host "Scanning subdirectory $($SubDir)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget3.$SubDir = GenerateDirArray -CurrentDirToAnalyze $SubDir
        }
    }
}

Write-Host "`nDone scanning the filesystem at $(Get-Date -Format "dd/MM/yyyy HH:mm"). Logfile appended:" -ForegroundColor Green
"`nDone scanning the filesystem at $(Get-Date -Format "dd/MM/yyyy HH:mm"). Logfile appended:$($Logfile)" | Out-File $Logfile -Append

# Cleaning up after Part 0
try {
    $LogStream.Close() | Out-Null
    Remove-SSHSession -SSHSession $Part0Session | Out-Null
}
catch {

}
finally {
    # Nullifying used objects.
    $LogStream, $Part0Session, $DirectoryHashtableTarget3, $DirectoryHashtableTarget2, $DirectoryHashtableTarget1, 
    $DirectoryHashtable, $DirectoryHashtableTarget2KeyLoop, $DirectoryHashtableTarget1KeyLoop | ForEach-Object { $PSItem = $null }
}

Write-Host $Logfile -ForegroundColor Green
#endregion

#region Part 1 - Setting up SSH Session
##### Part 1: CVE-2022-42475 sslvpn heap-based buffer overflow IoC's

# Setting up the Part1Session SSH Session and Stream with a Try/Catch, until the CommandStream is ready to process cmdlets
do {
    try {
        if ($null -eq $Part1Session) { throw "No.Active.Session" }
        elseif ($true -ne $Part1Session.Connected) { throw "No.Active.Session" }
        elseif ($false -eq $Part1Stream.CanWrite) { throw "No.Active.Stream" }
        elseif($true -eq $Part1Stream.CanWrite){ Write-Host "SSH Streams are ready." -ForegroundColor Green }
    }
    catch {
        # Catch 1 for setting up a new session and a new CommandStream
        if ($PSItem.Exception.Message -eq "No.Active.Session") {
            Write-Host "Setting up SSH Session for Part 1" -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH Session for Part 1" | Out-File $Logfile -Append
            $Part1Session = New-SSHSession -ComputerName $IP -Credential $creds -AcceptKey -Port $SSHPort

            Write-Host "Setting up SSH CMDlet Stream..." -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Stream for Part 1..." | Out-File $Logfile -Append
            $Part1Stream = $Part1Session.Session.CreateShellStream("SSH-PART1-STREAM", 0, 0, 0, 0, 4096)
        }
        
        # Catch 2 for opening the CommandStream when there is none, or when property CanWrite is False
        elseif ($PSItem.Exception.Message -eq "No.Active.Stream") {
            Write-Host "Setting up SSH CMDlet Stream..." -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Stream for Part 1..." | Out-File $Logfile -Append
            $Part1Stream = $Part1Session.Session.CreateShellStream("SSH-PART1-STREAM", 0, 0, 0, 0, 4096)
        }
    }
}until($true -eq $Part1Stream.CanWrite)
#endregion

#region Part 1: Stage 1 - Scanning systemlogs for application crashes
<#
Targets:
Logdesc="Application crashed" and msg="[...] application: sslvpnd,[...], Signal 11 received, Backtrace: [...]“

Tools:
FortiOS: Display logs in CLI when there's a match in criteria.

execute log filter category 1
execute log filter field logdesc 'Application crashed'
execute log filter field msg '*application: sslvpnd*'
execute log display
#>

Write-Host `n"Stage 1: Scanning systemlogs for application crashes" -ForegroundColor Yellow
"Part 1 Stage 1: Scanning systemlogs for application crashes" | Out-File $Logfile -Append
Invoke-SSHStreamShellCommand -ShellStream $Part1Stream -Command "execute log filter category 1" | Out-Null
Invoke-SSHStreamShellCommand -ShellStream $Part1Stream -Command "execute log filter field logdesc 'Application crashed'" | Out-Null
Invoke-SSHStreamShellCommand -ShellStream $Part1Stream -Command "execute log filter field msg '*application: sslvpnd*'" | Out-Null
$Part1Stage1Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stream -Command "execute log display"
$Part1Stage1Output | Out-File $Logfile -Append

if (($Part1Stage1Output | Where-Object { $_ -ne "" }) -match "0 logs returned") {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo logs found in system log that matched the criteria!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo logs found in system log that matched the criteria!" | Out-File $Logfile -Append 
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWell, we've found something, let's check it out." -ForegroundColor Yellow
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWell, we've found something, let's check it out." | Out-File $Logfile -Append
    $Part1Stage1Output 
}
#endregion

#region Part 1: Stage 2 - Scanning of the crash debug logfiles
<#
Targets:
Look for application sslvpnd crashes

Tools:
FortiOS: Display crashlog in CLI and analyse output with Powershell.

diagnose debug crashlog read
#>

Write-Host `n"Stage 2: Scanning of the crash debug logfiles" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 1 Stage 2: Scanning of the crash debug logfiles" | Out-File $Logfile -Append
Write-Host `n"If logs are not sequential with both 'application sslvpnd' and 'signal 11 (Segmentation fault) received' as a match, than these errors are of a different daemon and can be ignored." -ForegroundColor Yellow
$Part1Stage2Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stream -Command "diagnose debug crashlog read"
$CrashLogEntries = @("application sslvpnd", "signal 11 (Segmentation fault) received")
$Part1Stage2MatchingLines = $Part1Stage2Output | Select-String -SimpleMatch -List $CrashLogEntries
$Part1Stage2MatchingLines | Out-File $Logfile -Append
$Part1Stage2MatchingLines
#endregion

#region Part 1: Stage 3 - Scan for Suspicious filesystem entries
<#
Targets:
https://community.fortinet.com/t5/FortiGate/Technical-Tip-Critical-vulnerability-Protect-against-heap-based/ta-p/239420
Dir:/data/lib 
    /data/lib/libips.bak
    /data/lib/libgif.so
    /data/lib/libiptcp.so
    /data/lib/libipudp.so
    /data/lib/libjepg.so
Dir:/var
    /var/.sslvpnconfigbk
Dir:/data/etc
    /data/etc/wxd.conf
Dir:/
    /flash

Tools:
FortiOS: Using the $LogFile we've made earlier to collect (known) suspicious files.
Above are known file-locations, but using $AllFiles we are broadening our location scope to everywhere.
#>

Write-Host `n"Stage 3: Scan for Suspicious filesystem entries" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 1 Stage 3: Scan for Suspicious filesystem entries" | Out-File $Logfile -Append
$Part1Stage3MatchingFilenames = @("libips.bak", "libgif.so", "libiptcp.so", "libipudp.so", "libjepg.so", ".sslvpnconfigbk", "wxd.conf")
$Part1Stage3MatchingLines = Get-Content $AllFiles | Select-String -SimpleMatch -List $Part1Stage3MatchingFilenames

if ($null -eq $Part1Stage3MatchingLines) {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" | Out-File $Logfile -Append
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" -ForegroundColor Yellow
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" | Out-File $Logfile -Append
    $Part1Stage3MatchingLines | Out-File $Logfile -Append
    $Part1Stage3MatchingLines
}
#endregion

#region Part 1: Stage 4 - Find malicious connections FROM the Fortigate
<#
Targets:
https://www.fortinet.com/blog/psirt-blogs/analysis-of-fg-ir-22-398-fortios-heap-based-buffer-overflow-in-sslvpnd
IP/Domains
High Confidence
188.34.130.40       (port 444 observed)
103.131.189.143     (ports 30080,30081,30443,20443 observed)
193.36.119.61       (ports 8443,444 observed)
172.247.168.153     (port 8033 observed)
139.180.184.197
66.42.91.32
158.247.221.101
107.148.27.117
139.180.128.142
155.138.224.122
185.174.136.20
139.180.184.197
66.42.91.32
158.247.221.101
107.148.27.117
139.180.128.142
155.138.224.122
185.174.136.20
45.86.229.220
45.86.231.71
139.99.35.116
139.99.37.119
194.62.42.105
45.86.231.71
45.86.229.220
185.250.149.32
137.175.30.138
146.70.157.133

Older Actor IPs
156.251.162.76
156.251.163.122
156.251.163.19
156.251.162.111

Tools:
FortiOS: Use the Fortigate equivalant of netstat: diagnose sys tcpsock
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 4: Analyzing TCP Streams" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 1 Stage 4: Analyzing TCP Streams" | Out-File $Logfile -Append
$Part1Stage4Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stream -Command "diagnose sys tcpsock"
$Part1Stage4IPList = @("188.34.130.40", "103.131.189.143", "193.36.119.61", "172.247.168.153", "139.180.184.197", "66.42.91.32", "158.247.221.101", "107.148.27.117", "139.180.128.142", "155.138.224.122", "185.174.136.20", "139.180.184.197", "66.42.91.32", "158.247.221.101", "107.148.27.117", "139.180.128.142", "155.138.224.122", "185.174.136.20", "45.86.229.220", "45.86.231.71", "139.99.35.116", "139.99.37.119", "194.62.42.105", "45.86.231.71", "45.86.229.220", "185.250.149.32", "137.175.30.138", "146.70.157.133", "156.251.162.76", "156.251.163.122", "156.251.163.19", "156.251.162.111")
$Part1Stage4Output | Out-File $Logfile -Append
$Part1Stage4MatchingLines = $Part1Stage4Output | Select-String -SimpleMatch -List $Part1Stage4IPList

if ($null -eq $Part1Stage4MatchingLines) {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious connections found!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious connections found!" | Out-File $Logfile -Append
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something!"`n
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something!" | Out-File $Logfile -Append
    $Part1Stage4MatchingLines | Out-File $Logfile -Append
    $Part1Stage4MatchingLines
}

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nEnd of Part 1, closing SSH session." -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nEnd of Part 1, closing SSH session." | Out-File $Logfile -Append

# Cleaning up after Part 1
try {
    $Part1Stream.Close() | Out-Null
    Remove-SSHSession -SSHSession $Part1Session | Out-Null
}
catch {

}
finally {
    # Nullifying used objects.
    $Part1Stream, $Part1Session, $Part1Stage4Output, $Part1Stage4MatchingLines, $Part1Stage4IPList,
    $Part1Stage3MatchingLines, $Part1Stage3MatchingFilenames, $Part1Stage2MatchingLines, $CrashLogEntries, 
    $Part1Stage2Output, $Part1Stage1Output | ForEach-Object { $PSItem = $null }
}

##### End of Part 1.
#endregion

#region Part 2 - Setting up SSH Session
##### Part 2: COATHANGER-Malware

# Setting up the Part2Session SSH Session and Stream with a Try/Catch, until the CommandStream is ready to process cmdlets
do {
    try {
        if ($null -eq $Part2Session) { throw "No.Active.Session" }
        elseif ($true -ne $Part2Session.Connected) { throw "No.Active.Session" }
        elseif ($false -eq $Part2Stream.CanWrite) { throw "No.Active.Stream" }
        elseif($true -eq $Part2Stream.CanWrite){ Write-Host "SSH Streams are ready." -ForegroundColor Green }
    }
    catch {
        # Catch 1 for setting up a new session and a new CommandStream
        if ($PSItem.Exception.Message -eq "No.Active.Session") {
            Write-Host "Setting up SSH Session for Part 2" -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH Session for Part 2" | Out-File $Logfile -Append
            $Part2Session = New-SSHSession -ComputerName $IP -Credential $creds -AcceptKey -Port $SSHPort

            Write-Host "Setting up SSH CMDlet Stream..." -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Stream for Part 2..." | Out-File $Logfile -Append
            $Part2Stream = $Part2Session.Session.CreateShellStream("SSH-PART2-STREAM", 0, 0, 0, 0, 4096)
        }
        
        # Catch 2 for opening the CommandStream when there is none, or when property CanWrite is False
        elseif ($PSItem.Exception.Message -eq "No.Active.Stream") {
            Write-Host "Setting up SSH CMDlet Stream..." -ForegroundColor Green
            "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Stream for Part 2..." | Out-File $Logfile -Append
            $Part2Stream = $Part2Session.Session.CreateShellStream("SSH-PART2-STREAM", 0, 0, 0, 0, 4096)
        }
    }
}until($true -eq $Part2Stream.CanWrite)
#endregion

#region Part 2: Stage 1 - Scan for Suspicious filesystem entries
<#
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear
Filenames comes from 3.3 and 'Appendix 1: YARA rules'

Dir:/data2
    /data2/.bd.key/authd
    /data2/.bd.key/httpsd
    /data2/.bd.key/newcli
    /data2/.bd.key/preload.so
    /data2/.bd.key/sh -> gives a LOT of junk to process, so it's not in the array, please check presence and hash manually.
Dir:/bin
    /bin/smartctl
    /data/bin/smartctl
Dir:/lib
    /lib/liblog.so
Dir:/etc
    /etc/ld.so.preload
Dir:/tmp
    /tmp/packfile

Tools:
FortiOS: Using the $LogFile we've made earlier to collect (known) suspicious files.
Above are known file-locations, but using $AllFiles we are broadening our location scope to everywhere.
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 1: Scan for Suspicious filesystem entries" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 2 Stage 1: Scan for Suspicious filesystem entries" | Out-File $Logfile -Append

$Part2Stage1MatchingFilenames = @("authd", "httpsd", "newcli", "preload.so","smartctl", "liblog.so", "ld.so.preload", "packfile")
$Part2Stage1MatchingLines = Get-Content $AllFiles | Select-String -SimpleMatch -List $Part2Stage1MatchingFilenames

if ($null -eq $Part2Stage1MatchingLines) {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" | Out-File $Logfile -Append
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" -ForegroundColor Yellow
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" | Out-File $Logfile -Append; Start-Sleep 2;
    $Part2Stage1MatchingLines | Out-File $Logfile -Append
    $Part2Stage1MatchingLines
}
#endregion

#region Part 2: Stage 2 - Find malicious connections FROM the Fortigate
<#
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear

There's no IP addresses list to look for that are suspicious.
We should look for processes that connect to external IP that are not trusted.
In the document it mentions httpsd, but these connections may vary in which process-name they tend to use.

Tools:
FortiOS: Use the Fortigate equivalant of netstat: diagnose sys tcpsock
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 2: Analyzing TCP Streams" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 2 Stage 2: Analyzing TCP Streams" | Out-File $Logfile -Append
$Part2Stage2Output = Invoke-SSHStreamShellCommand -ShellStream $Part2Stream -Command "diagnose sys tcpsock"
$Part2Stage2Output | Out-File $Logfile -Append

Write-Host "Please look for suspicious external connections:"; $Part2Stage2Output
#endregion

#region Part 2: Stage 3 - Analyse the processes for anomalies, with extra attention to PID's captured in Stage 2
<#
Targets:

Tools:

Get all running processes:
fnsysctl ps

Get all PID's of a specific processname:
diagnose sys process pidof httpsd

diagnose sys process dump <PID>
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 3: Analyzing Running Processes" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 3: Analyzing Running Processes" | Out-File $Logfile -Append
$Part2Stage3Output = Invoke-SSHStreamShellCommand -ShellStream $Part2Stream -Command "fnsysctl ps"
$Part2Stage3Outputhttpsd = Invoke-SSHStreamShellCommand -ShellStream $Part2Stream -Command "diagnose sys process pidof httpsd"
$Part2Stage3Output | Out-File $Logfile -Append
$Part2Stage3Outputhttpsd = $Part2Stage3Outputhttpsd | Where-Object { $_ -ne "" }

$Part2Stage3Patterns = @("Gid", "(deleted)", "Gid", "libpe.so", "smartctl", "authd", "httpsd", "newcli", "preload.so", "liblog.so", "packfile", "ld.so.preload", "unpack.so")

foreach ($httpsdPID in $Part2Stage3Outputhttpsd) {
    $CMDlet = "diagnose sys process dump " + $httpsdPID
    $Part2Stage3OutputhttpsdCheck = Invoke-SSHStreamShellCommand -ShellStream $Part2Stream -Command $CMDlet
    $CMDlet | Out-File $Logfile -Append
    $Part2Stage3OutputhttpsdCheck | Select-String -SimpleMatch -List $Part2Stage3Patterns -CaseSensitive | Out-File $Logfile -Append
    $Part2Stage3OutputhttpsdCheck | Select-String -SimpleMatch -List $Part2Stage3Patterns -CaseSensitive
}
#endregion

#region Part 2: Stage 4 - Generate hashes and compare them to known list of hashed related to COATHANGER
<#
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear
Appendix 2: Checksums

Files:
libpe.so
smartctl
authd
httpsd
newcli
preload.so
sh
liblog.so
packfile
ld.so.preload
unpack.so

We need to check the hashes of all matching filenames from Stage 1 to a CSV from known compromised files and their hashes.
There's multiple hashes in the document to check.

Tools: FortiOS computing MD5 hashes:
diagnose sys csum /data2/.bd.key/httpsd
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 4: Generating MD5 hashes and matching to known IoC" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 4: Generating MD5 hashes and matching to known IoC" | Out-File $Logfile -Append

function CheckHashes($Files) {
    Foreach ($File in $Files) {
        if ($null -ne $File) {
            # Generate cmdlet for MD5 generation on Fortigate with current filename
            $Part2Stage4HashCommand = "diagnose sys csum " + $File
            # Fetch cmdlet output
            $Part2Stage4HashOutput = Invoke-SSHStreamShellCommand -ShellStream $Part2Stream -Command $Part2Stage4HashCommand
            $Part2Stage4HashOutput | Out-File $Logfile -Append
            # Format output results for MF5 Hash only
            $CurrentHash = ((($Part2Stage4HashOutput -split ":") -split " ") -ne $File) -join ""
            # Compare to CSV
            if ($CurrentHash -in $AllHashes.MD5) {
                Write-Host "MD5-hash match on file $($File)" -ForegroundColor Red
                "MD5-Hash Match on file $($File)" | Out-File $Logfile -Append
            }
            else {
                Write-Host "No MD5-hash match on file $($File)" -ForegroundColor Green
                "No MD5-Hash match on file $($File)" | Out-File $Logfile -Append
            }
        }
    }
}

if ($null -eq $Part2Stage1MatchingLines) { Write-Host "No hash-checking required, no matching files were found!" -ForegroundColor Green }
else { CheckHashes -Files $Part2Stage1MatchingLines }

Write-Host `n"End of Part 2, closing SSH session." -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nEnd of Part 2, closing SSH session." | Out-File $Logfile -Append

# Cleaning up after Part 2
try {
    $Part2Stream.Close() | Out-Null
    Remove-SSHSession -SSHSession $Part2Session | Out-Null
}
catch {

}
finally {
    # Nullifying used objects.
    $Part1Stream, $Part1Session, $Part2Stage1MatchingLines, $Part2Stage3OutputhttpsdCheck,
    $CMDlet, $httpsdPID, $Part2Stage3Patterns, $Part2Stage3Output, $Part2Stage2Output,
    $Part2Stage1MatchingLines, $Part2Stage1MatchingFilenames  | ForEach-Object { $PSItem = $null }
}

Stop-Transcript
#endregion