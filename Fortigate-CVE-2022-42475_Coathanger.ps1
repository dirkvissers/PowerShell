<#
Dirk Vissers:
Using the Powershell PoshSSH-module to recusively scan for files within the directories that might give IoCs for CVE-2022-42475 and COATHANGER-malware.

Part 0 Before we begin... let's get the bulk out of the way: generating an overview of Fortigate and it's folderstructures and it's contents.

Part 1 will be for CVE-2022-42475 IoC's:

    - Stage 1: Logdesc="Application crashed" and msg="[...] application: sslvpnd,[...], Signal 11 received, Backtrace: [...]“
    - Stage 2: Debug Crash-logs
    - Stage 3: Suspicious filesystem entries
    - Stage 4: Find malicious connections FROM the Fortigate

Part 2 will be for COATHANGER IoC's:

    - Stage 1: Suspicious filesystem entries
    - Stage 2: Diagnose active TCP Socket List for external IP's and the process that is using it (including PID)
    - Stage 3: Analyse the processes for anomalies, with extra attention to PID's captured in Stage 2
    - Stage 4: Generate hashes and compare them to known list of hashed related to COATHANGER

#>

$FilePath = ($MyInvocation.MyCommand.Source -split ($MyInvocation.MyCommand.Name))[0] + "Fortigate-CVE-2022-42475_Coathanger-$(Get-Date -Format "dd/MM/yyyy-HH-mm")"
$Logfile = $FilePath + "-log.log"
$Transcript = $FilePath + "-transcript.log"
$AllFiles = $FilePath + "-files.log"

Start-Transcript -Path $Transcript -IncludeInvocationHeader

if ($null -eq $Logfile) { Write-Error "No Logging patch set. Exiting script..."; Stop-Transcript;exit }
else { Write-Host "LogFile set at $($Logfile)" -ForegroundColor Green }

Write-Host "Fortigate SSH Script for CVE-2022-42475 and Coathanger IoC's." -ForegroundColor Green
"Fortigate SSH Script for CVE-2022-42475 and Coathanger IoC's." | Out-File $Logfile -Append
Write-Host "Fetching CSV containing all known IoC hashes..." -ForegroundColor Green
"Fetching CSV containing all known IoC hashes..." | Out-File $Logfile -Append

$GitHubRawCsv = (Invoke-WebRequest -Uri "https://raw.githubusercontent.com/dirkvissers/PowerShell/refs/heads/main/Coathanger-IoC-hashes.csv").Content
$CsvFilePath = ($MyInvocation.MyCommand.Source -split ($MyInvocation.MyCommand.Name))[0] + "Coathanger-IoC-hashes.csv"
Set-Content -Path $CsvFilePath -Value $GitHubRawCsv  -Force
$AllHashes = Import-CSV $CsvFilePath -Delimiter ";"

if ($null -ne $AllHashes) {
    Write-Host "Successfully fetched hashes!" -ForegroundColor Green
    "Successfully fetched hashes!" | Out-File $Logfile -Append
}
else {
    Write-Error "Failed to fetch CSV, exiting script... "
    "Failed to fetch CSV, exiting script... " | Out-File $Logfile -Append
    Stop-Transcript
    exit
}

Write-Host `n"Activating Posh-SSH Powershell Module..." -ForegroundColor Green
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nFortigate SSH Script for CVE-2022-42475 and Coathanger IoC's." | Out-File $Logfile -Append
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nActivating Posh-SSH Powershell Module..." | Out-File $Logfile -Append


Install-Module -Name Posh-SSH -Scope CurrentUser -Force -AllowClobber -WarningAction SilentlyContinue
Import-Module -Name Posh-SSH -Force -WarningAction SilentlyContinue

Write-Host "Gathering credential for current session..." -ForegroundColor Green
$creds = Get-Credential
if ($null -eq $creds) {
    Write-Error "No valid credentials were give. Exiting script..."
    "No valid credentials were give. Exiting script..." | Out-File $Logfile -Append
    Stop-Transcript
    exit
}

$IP = Read-Host "Enter the IP-address we are connecting to"
if ($false -eq ((Test-Connection $IP -Count 1).Status -eq "Success")) {
    Write-Error "The IP-address $(IP) is not reachable. Exiting script."
    "The IP-address $($IP) is not reachable. Exiting script." | Out-File $Logfile -Append
    Stop-Transcript
    exit
}

if ($null -eq $Part1Session) {
    Write-Host "Setting up SSH Session for Part 0 and 1" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH Session for Part 0 and 1" | Out-File $Logfile -Append
    $Part1Session = New-SSHSession -ComputerName $IP -Credential $creds -AcceptKey
    Write-Host "Setting up SSH CMDlet Streams per part stage..." -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Streams per part stage..." | Out-File $Logfile -Append
    $Part1Stage1Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST1", 0, 0, 0, 0, 2048)
    $Part1Stage2Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST2", 0, 0, 0, 0, 2048)
    $Part1Stage3Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST3", 0, 0, 0, 0, 2048)
    $Part1Stage4Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST4", 0, 0, 0, 0, 2048)

    $LogStream = $Part1Session.Session.CreateShellStream("SSH-LOG-STREAM", 0, 0, 0, 0, 2048)
}

$Part1Stage1Stream, $Part1Stage2Stream, $Part1Stage3Stream, $Part1Stage4Stream, $LogStream | ForEach-Object {
    if ($false -eq $_.CanWrite) {
        Write-Error "SSH Streams incomplete. Closing SSH Session and exiting script..."
        "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSSH Streams incomplete. Closing SSH Session and exiting script..." | Out-File $Logfile -Append
        Remove-SSHSession -SSHSession $Part1Session | Out-Null
        Stop-Transcript
        exit
    }
}

<# Stage 0: Iterating through the folderstructure.
Target:
Contents of every folders, subfolders and putting the results into a logfile.

Tools:
Powershell: Using SSH to get all the current contents of the Fortigate.
Using 3 functions and iterating through generated hashtables 3 times would get us to our folder-structure 'dead-end'.

All contents will be put into a logfile which we will use multiple times in this script.

FortiOS: Using fortinet system control (fnsysctl) ls-cmdlet with -la parameter for showing hidden files and folders.
#>

function SearchForFiles($SearchList, $MainDirectory) {
    # Splitting the SSH Output string to select the last entry, which contains the name of the file/folder
    $SearchList | ForEach-Object {
        $LineArrayFiles = @($_ -split " " | Where-Object { $_ -ne "" })
        if ( ($LineArrayFiles[0] -notmatch "dr" ) -and ($LineArrayFiles[0] -notmatch "lr" ) -and ($LineArrayFiles[0] -notmatch "br" ) -and ($LineArrayFiles[0] -notmatch "cr" ) -and ( $LineArrayFiles[0] -notin ($null, "", " ") ) ) {
            # Filtering files and adding them to the array $RecursiveFileList for later scanning
            $LineArrayFilesFilteredDirectory = $LineArrayFiles[$LineArrayFiles.Count - 1]
            if ( ($LineArrayFilesFilteredDirectory -notmatch @("/.", "/..")) -and ($LineArrayFilesFilteredDirectory -notmatch "->") ) {
                # Need an exception for the root directory of the Fortigate, otherwise we would have //filename and that would break cmdlets later on                
                if ($MainDirectory -eq "/") { $MainDirectory + $LineArrayFilesFilteredDirectory >> $AllFiles }
                else { ($MainDirectory + "/" + $LineArrayFilesFilteredDirectory) >> $AllFiles } 
            }
        }
    }
}

function SearchForDirs($SearchList) {
    # Splitting the SSH Output string to select the last entry, which contains the name of the file/folder
    $SearchList | ForEach-Object {
        $LineArrayDirectories = @($_ -split " " | Where-Object { $_ -ne "" })
        # Filtering directories and adding them to the hashtable for later scanning
        if ($LineArrayDirectories[0] -match "dr") {
            $LineArrayFilteredDirectory = "/" + $LineArrayDirectories[$LineArrayDirectories.Count - 1]
            if ($LineArrayFilteredDirectory -notin @("/.", "/..")) { $LineArrayFilteredDirectory }
        }
    }
}

function GenerateRootArray {
    # Using the SearchForDirs to look for directories and putting the results-array into the $DirectoryHashtable
    $Stage0RootCommand = "fnsysctl ls -la /"
    $Part0Output = Invoke-SSHStreamShellCommand -ShellStream $LogStream -Command $Stage0RootCommand
    Set-Content $Logfile -Value $Stage0RootCommand
    $Part0Output | Out-File $Logfile -Append
    # Formatting output to search for files and adding these to an array for ease of use when searching through the filesystem and generating hashes
    SearchForFiles -MainDirectory "/" -SearchList $Part0Output
    # Generating a list of contents, formatting it and creating an array to put into the hashtable
    $DirectoryHashtable."/" = SearchForDirs -SearchList $Part0Output
}

function GenerateDirArray ($CurrentDirToAnalyze) {
    $Stage0DirCommand = "fnsysctl ls -la " + $CurrentDirToAnalyze
    $Part0DirArrayOutput = Invoke-SSHStreamShellCommand -ShellStream $LogStream -Command $Stage0DirCommand
    $Stage0DirCommand | Out-File $Logfile -Append
    $Part0DirArrayOutput | Out-File $Logfile -Append
    # Formatting output to search for files and adding these to an array for ease of use when searching through the filesystem and generating hashes
    SearchForFiles -MainDirectory $CurrentDirToAnalyze -SearchList $Part0DirArrayOutput
    # Generating a list of contents, formatting it and creating an array to put into the hashtable
    SearchForDirs -SearchList $Part0DirArrayOutput
}

$DirectoryHashtable = @{}
Write-Host "Generating the initial Root Directory Overview" -ForegroundColor Green
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nGenerating the initial Root Directory Overview" | Out-File $Logfile -Append

GenerateRootArray

# Hashtable run using Root Array Directory Hashtable
Write-Host "Generating Fortigate Root directory overview" -ForegroundColor Yellow

$DirectoryHashtableKeyLoop = $DirectoryHashtable.Keys
$DirectoryHashtableTarget1 = @{}

foreach ($HashKey in $DirectoryHashtableKeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtable.$HashKey) {
        if ($null -ne $Directory) {
            Write-Host "Scanning subdirectory $($Directory)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget1.$Directory = GenerateDirArray -CurrentDirToAnalyze $Directory
        }
    }
}

# Hashtable second run using previous target table $DirectoryHashtableTarget1
Write-Host "Generating Fortigate second level directory overview" -ForegroundColor Yellow
$DirectoryHashtableTarget1KeyLoop = $DirectoryHashtableTarget1.Keys
$DirectoryHashtableTarget2 = @{}

foreach ($HashKey in $DirectoryHashtableTarget1KeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtableTarget1.$HashKey) {
        if ($null -ne $Directory) {
            $SubDir = $HashKey + $Directory
            Write-Host "Scanning subdirectory $($SubDir)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget2.$SubDir = GenerateDirArray -CurrentDirToAnalyze $SubDir
        }
    }
}

# Hashtable third run using previous target table $DirectoryHashtableTarget2
Write-Host "Generating Fortigate third level directory overview" -ForegroundColor Yellow
$DirectoryHashtableTarget2KeyLoop = $DirectoryHashtableTarget2.Keys
$DirectoryHashtableTarget3 = @{}

foreach ($HashKey in $DirectoryHashtableTarget2KeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtableTarget3.$HashKey) {
        if ($null -ne $Directory) {
            $SubDir = $HashKey + $Directory
            Write-Host "Scanning subdirectory $($SubDir)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget3.$SubDir = GenerateDirArray -CurrentDirToAnalyze $SubDir
        }
    }
}

Write-Host "`nDone scanning the filesystem at $(Get-Date -Format "dd/MM/yyyy HH:mm"). Logfile appended:" -ForegroundColor Green
"`nDone scanning the filesystem at $(Get-Date -Format "dd/MM/yyyy HH:mm"). Logfile appended:$($Logfile)" | Out-File $Logfile -Append

Write-Host $Logfile -ForegroundColor Green

##### Part 1: CVE-2022-42475 sslvpn heap-based buffer overflow IoC's

<# Stage 1: Scanning systemlogs for application crashes
Targets:
Logdesc="Application crashed" and msg="[...] application: sslvpnd,[...], Signal 11 received, Backtrace: [...]“

Tools:
FortiOS: Display logs in CLI when there's a match in criteria.

execute log filter category 1
execute log filter field logdesc 'Application crashed'
execute log filter field msg '*application: sslvpnd*'
execute log display
#>

Write-Host `n"Stage 1: Scanning systemlogs for application crashes" -ForegroundColor Yellow
"Part 1 Stage 1: Scanning systemlogs for application crashes" | Out-File $Logfile -Append
Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log filter category 1" | Out-Null
Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log filter field logdesc 'Application crashed'" | Out-Null
Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log filter field msg '*application: sslvpnd*'" | Out-Null
$Part1Stage1Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log display"
$Part1Stage1Output | Out-File $Logfile -Append

if (($Part1Stage1Output | Where-Object { $_ -ne "" }) -match "0 logs returned") {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo logs found in system log that matched the criteria!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo logs found in system log that matched the criteria!" | Out-File $Logfile -Append 
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWell, we've found something, let's check it out." -ForegroundColor Yellow
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWell, we've found something, let's check it out." | Out-File $Logfile -Append
    $Part1Stage1Output 
}

<# Stage 2: Scanning of the crash debug logfiles
Targets:
Look for application sslvpnd crashes

Tools:
FortiOS: Display crashlog in CLI and analyse output with Powershell.

diagnose debug crashlog read
#>

Write-Host `n"Stage 2: Scanning of the crash debug logfiles" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 1 Stage 2: Scanning of the crash debug logfiles" | Out-File $Logfile -Append
Write-Host `n"If logs are not sequential with both 'application sslvpnd' and 'signal 11 (Segmentation fault) received' as a match, than these errors are of a different daemon and can be ignored." -ForegroundColor Yellow
$Part1Stage2Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stage2Stream -Command "diagnose debug crashlog read"
$CrashLogEntries = @("application sslvpnd", "signal 11 (Segmentation fault) received")
$Part1Stage2MatchingLines = $Part1Stage2Output | Select-String -SimpleMatch -List $CrashLogEntries
$Part1Stage2MatchingLines | Out-File $Logfile -Append
$Part1Stage2MatchingLines

<# Stage 3: Scan for Suspicious filesystem entries
Targets:
https://community.fortinet.com/t5/FortiGate/Technical-Tip-Critical-vulnerability-Protect-against-heap-based/ta-p/239420
Dir:/data/lib 
    /data/lib/libips.bak
    /data/lib/libgif.so
    /data/lib/libiptcp.so
    /data/lib/libipudp.so
    /data/lib/libjepg.so
Dir:/var
    /var/.sslvpnconfigbk
Dir:/data/etc
    /data/etc/wxd.conf
Dir:/
    /flash

Tools:
FortiOS: Using the $LogFile we've made earlier to collect (known) suspicious files.
Above are known file-locations, but using $LogFile we are broadening our location scope to everywhere.
#>

Write-Host `n"Stage 3: Scan for Suspicious filesystem entries" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 1 Stage 3: Scan for Suspicious filesystem entries" | Out-File $Logfile -Append
$Part1Stage3MatchingFilenames = @("libips.bak", "libgif.so", "libiptcp.so", "libipudp.so", "libjepg.so", ".sslvpnconfigbk", "wxd.conf")
$Part1Stage3MatchingLines = Get-Content $AllFiles | Select-String -SimpleMatch -List $Part1Stage3MatchingFilenames

if ($null -eq $Part1Stage3MatchingLines) {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" | Out-File $Logfile -Append
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" -ForegroundColor Yellow
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" | Out-File $Logfile -Append
    $Part1Stage3MatchingLines | Out-File $Logfile -Append
    $Part1Stage3MatchingLines
}

<# Stage 4: Find malicious connections FROM the Fortigate
Targets:
https://www.fortinet.com/blog/psirt-blogs/analysis-of-fg-ir-22-398-fortios-heap-based-buffer-overflow-in-sslvpnd
IP/Domains
High Confidence
188.34.130.40       (port 444 observed)
103.131.189.143     (ports 30080,30081,30443,20443 observed)
193.36.119.61       (ports 8443,444 observed)
172.247.168.153     (port 8033 observed)
139.180.184.197
66.42.91.32
158.247.221.101
107.148.27.117
139.180.128.142
155.138.224.122
185.174.136.20
139.180.184.197
66.42.91.32
158.247.221.101
107.148.27.117
139.180.128.142
155.138.224.122
185.174.136.20
45.86.229.220
45.86.231.71
139.99.35.116
139.99.37.119
194.62.42.105
45.86.231.71
45.86.229.220
185.250.149.32
137.175.30.138
146.70.157.133

Older Actor IPs
156.251.162.76
156.251.163.122
156.251.163.19
156.251.162.111

Tools:
FortiOS: Use the Fortigate equivalant of netstat: diagnose sys tcpsock
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 4: Analyzing TCP Streams" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 1 Stage 4: Analyzing TCP Streams" | Out-File $Logfile -Append
$Part1Stage4Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stage4Stream -Command "diagnose sys tcpsock"
$Part1Stage4IPList = @("188.34.130.40", "103.131.189.143", "193.36.119.61", "172.247.168.153", "139.180.184.197", "66.42.91.32", "158.247.221.101", "107.148.27.117", "139.180.128.142", "155.138.224.122", "185.174.136.20", "139.180.184.197", "66.42.91.32", "158.247.221.101", "107.148.27.117", "139.180.128.142", "155.138.224.122", "185.174.136.20", "45.86.229.220", "45.86.231.71", "139.99.35.116", "139.99.37.119", "194.62.42.105", "45.86.231.71", "45.86.229.220", "185.250.149.32", "137.175.30.138", "146.70.157.133", "156.251.162.76", "156.251.163.122", "156.251.163.19", "156.251.162.111")
$Part1Stage4Output | Out-File $Logfile -Append
$Part1Stage4MatchingLines = $Part1Stage4Output | Select-String -SimpleMatch -List $Part1Stage4IPList

if ($null -eq $Part1Stage4MatchingLines) {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious connections found!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious connections found!" | Out-File $Logfile -Append
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something!"`n
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something!" | Out-File $Logfile -Append
    $Part1Stage4MatchingLines | Out-File $Logfile -Append
    $Part1Stage4MatchingLines
}


Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nEnd of Part 1, closing SSH session." -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nEnd of Part 1, closing SSH session." | Out-File $Logfile -Append
Remove-SSHSession -SSHSession $Part1Session | Out-Null

##### End of Part 1.

##### Part 2: COATHANGER-Malware


if ($null -eq $Part2Session) {
    Write-Host "Setting up SSH Session for Part 2" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH Session for Part 2" | Out-File $Logfile -Append
    $Part2Session = New-SSHSession -ComputerName $IP -Credential $creds -AcceptKey
    Write-Host "Setting up SSH CMDlet Streams per part stage..." -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSetting up SSH CMDlet Streams per part stage..." | Out-File $Logfile -Append
    $Part2Stage1Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST1", 0, 0, 0, 0, 2048)
    $Part2Stage2Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST2", 0, 0, 0, 0, 2048)
    $Part2Stage3Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST3", 0, 0, 0, 0, 2048)
    $Part2Stage4Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST4", 0, 0, 0, 0, 2048)
}

$Part2Stage1Stream, $Part2Stage2Stream, $Part2Stage3Stream, $Part2Stage4Stream | ForEach-Object {
    if ($null -eq $_) {
        Write-Error "SSH Streams incomplete. Closing SSH Session and exiting script..."
        "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nSSH Streams incomplete. Closing SSH Session and exiting script..." | Out-File $Logfile -Append
        Remove-SSHSession -SSHSession $Part2Session | Out-Null
        Stop-Transcript
        exit
    }
}


<# Stage 1: Scan for Suspicious filesystem entries
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear
Filenames comes from 3.3 and 'Appendix 1: YARA rules'

Dir:/data2
    /data2/.bd.key/authd
    /data2/.bd.key/httpsd
    /data2/.bd.key/newcli
    /data2/.bd.key/preload.so
    /data2/.bd.key/sh
Dir:/bin
    /bin/smartctl
    /data/bin/smartctl
Dir:/lib
    /lib/liblog.so
Dir:/etc
    /etc/ld.so.preload
Dir:/tmp
    /tmp/packfile

Files:
    authd
    httpsd
    newcli
    preload.so
    sh
    smartctl
    liblog.so
    ld.so.preload
    packfile

Tools:
FortiOS: Using the $LogFile we've made earlier to collect (known) suspicious files.
Above are known file-locations, but using $LogFile we are broadening our location scope to everywhere.
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 1: Scan for Suspicious filesystem entries" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 2 Stage 1: Scan for Suspicious filesystem entries" | Out-File $Logfile -Append

$Part2Stage1MatchingFilenames = @("authd", "httpsd", "newcli", "preload.so", "sh","smartctl", "liblog.so", "ld.so.preload", "packfile")
$Part2Stage1MatchingLines = Get-Content $AllFiles | Select-String -SimpleMatch -List $Part2Stage1MatchingFilenames

if ($null -eq $Part2Stage1MatchingLines) {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" -ForegroundColor Green
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nNo suspicious files found!" | Out-File $Logfile -Append
}
else {
    Write-Host "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" -ForegroundColor Yellow
    "$(Get-Date -Format "dd/MM/yyyy HH:mm")`nWe've found something, let's check it out!" | Out-File $Logfile -Append; Start-Sleep 2;
    $Part2Stage1MatchingLines | Out-File $Logfile -Append
    $Part2Stage1MatchingLines
}



<# Stage 2: Find malicious connections FROM the Fortigate
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear

There's no IP addresses list to look for that are suspicious.
We should look for processes that connect to external IP that are not trusted.
In the document it mentions httpsd, but these connections may vary in which process-name they tend to use.

Tools:
FortiOS: Use the Fortigate equivalant of netstat: diagnose sys tcpsock
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 2: Analyzing TCP Streams" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nPart 2 Stage 2: Analyzing TCP Streams" | Out-File $Logfile -Append
$Part2Stage2Output = Invoke-SSHStreamShellCommand -ShellStream $Part2Stage2Stream -Command "diagnose sys tcpsock"
$Part2Stage2Output | Out-File $Logfile -Append

Write-Host "Please look for suspicious external connections:"; $Part2Stage2Output

<# Stage 3: Analyse the processes for anomalies, with extra attention to PID's captured in Stage 2
Targets:

Tools:

Get all running processes:
fnsysctl ps

Get all PID's of a specific processname:
diagnose sys process pidof httpsd

diagnose sys process dump <PID>
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 3: Analyzing Running Processes" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 3: Analyzing Running Processes" | Out-File $Logfile -Append
$Part2Stage3Output = Invoke-SSHStreamShellCommand -ShellStream $Part2Stage3Stream -Command "fnsysctl ps"
$Part2Stage3Outputhttpsd = Invoke-SSHStreamShellCommand -ShellStream $Part2Stage3Stream -Command "diagnose sys process pidof httpsd"
$Part2Stage3Output | Out-File $Logfile -Append
$Part2Stage3Outputhttpsd = $Part2Stage3Outputhttpsd | Where-Object { $_ -ne "" }

$Part2Stage3Patterns = @("Gid", "(deleted)", "Gid", "libpe.so", "smartctl", "authd", "httpsd", "newcli", "preload.so", "sh", "liblog.so", "packfile", "ld.so.preload", "unpack.so")

foreach ($httpsdPID in $Part2Stage3Outputhttpsd) {
    $CMDlet = "diagnose sys process dump " + $httpsdPID
    $Part2Stage3OutputhttpsdCheck = Invoke-SSHStreamShellCommand -ShellStream $Part2Stage3Stream -Command $CMDlet
    $CMDlet | Out-File $Logfile -Append
    $Part2Stage3OutputhttpsdCheck | Select-String -SimpleMatch -List $Part2Stage3Patterns -CaseSensitive | Out-File $Logfile -Append
    $Part2Stage3OutputhttpsdCheck | Select-String -SimpleMatch -List $Part2Stage3Patterns -CaseSensitive
}

<# Stage 4: Generate hashes and compare them to known list of hashed related to COATHANGER
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear
Appendix 2: Checksums

Files:
libpe.so
smartctl
authd
httpsd
newcli
preload.so
sh
liblog.so
packfile
ld.so.preload
unpack.so

We need to check the hashes of all matching filenames from Stage 1 to a CSV from known compromised files and their hashes.
There's multiple hashes in the document to check.

Tools: FortiOS computing MD5 hashes:
diagnose sys csum /data2/.bd.key/httpsd
#>

Write-Host `n"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 4: Generating MD5 hashes and matching to known IoC" -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nStage 4: Generating MD5 hashes and matching to known IoC" | Out-File $Logfile -Append

function CheckHashes($Files) {
    Foreach ($File in $Files) {
        if ($null -ne $File) {
            # Generate cmdlet for MD5 generation on Fortigate with current filename
            $Part2Stage4HashCommand = "diagnose sys csum " + $File
            # Fetch cmdlet output
            $Part2Stage4HashOutput = Invoke-SSHStreamShellCommand -ShellStream $Part2Stage4Stream -Command $Part2Stage4HashCommand
            $Part2Stage4HashOutput | Out-File $Logfile -Append
            # Format output results for MF5 Hash only
            $CurrentHash = ((($Part2Stage4HashOutput -split ":") -split " ") -ne $File) -join ""
            # Compare to CSV
            if ($CurrentHash -in $AllHashes.MD5) {
                Write-Host "MD5-hash match on file $($File)" -ForegroundColor Red
                "MD5-Hash Match on file $($File)" | Out-File $Logfile -Append
            }
            else {
                Write-Host "No MD5-hash match on file $($File)" -ForegroundColor Green
                "No MD5-Hash match on file $($File)" | Out-File $Logfile -Append
            }
        }
    }
}

if ($null -eq $Part2Stage1MatchingLines) { Write-Host "No hash-checking required, no matching files were found!" -ForegroundColor Green }
else { CheckHashes -Files $Part2Stage1MatchingLines }

Write-Host `n"End of Part 2, closing SSH session." -ForegroundColor Yellow
"$(Get-Date -Format "dd/MM/yyyy HH:mm")`nEnd of Part 2, closing SSH session." | Out-File $Logfile -Append
Remove-SSHSession -SSHSession $Part2Session | Out-Null
Stop-Transcript