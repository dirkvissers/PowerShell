<#
Dirk Vissers:
Using the Powershell PoshSSH-module to recusively scan for files within the directories that might give IoCs for CVE-2022-42475 and COATHANGER-malware.

Part 0 Before we begin... let's get the bulk out of the way: generating an overview of Fortigate and it's folderstructures and it's contents.

Part 1 will be for CVE-2022-42475 IoC's:

    - Stage 1: Logdesc="Application crashed" and msg="[...] application: sslvpnd,[...], Signal 11 received, Backtrace: [...]“
    - Stage 2: Debug Crash-logs
    - Stage 3: Suspicious filesystem entries
    - Stage 4: Find malicious connections FROM the Fortigate

Part 2 will be for COATHANGER IoC's:

    - Stage 1: Suspicious filesystem entries
    - Stage 2: Diagnose active TCP Socket List for external IP's and the process that is using it (including PID)
    - Stage 3: Analyse the processes for anomalies, with extra attention to PID's captured in Stage 2
    - Stage 4: Generate hashes and compare them to known list of hashed related to COATHANGER

    #>

Write-Host "Fortigate SSH Script for CVE-2022-42475 and Coathanger IoC's." -ForegroundColor Green
Write-Host `n"Activating Posh-SSH Powershell Module..." -ForegroundColor Green

Install-Module -Name Posh-SSH -Force -AllowClobber -WarningAction SilentlyContinue
Import-Module -Name Posh-SSH -Force -WarningAction SilentlyContinue

Write-Host "Gathering credential for current session..." -ForegroundColor Green
$creds = Get-Credential
$IP = Read-Host "Enter the IP-address we are connecting to"


Write-Host "Setting up SSH Sessions..." -ForegroundColor Green
$Part1Session = New-SSHSession -ComputerName $IP -Credential $creds -AcceptKey
$Part2Session = New-SSHSession -ComputerName $IP -Credential $creds -AcceptKey

if (($null -eq $Part1Session) -or ($null -eq $Part2Session)) {
    Write-Error "No SSH Session found! Exiting script..."
    exit
}

Write-Host "Setting up SSH CMDlet Streams per part stage..." -ForegroundColor Green
$Part1Stage1Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST1", 0, 0, 0, 0, 2048)
$Part1Stage2Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST2", 0, 0, 0, 0, 2048)
$Part1Stage3Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST3", 0, 0, 0, 0, 2048)
$Part1Stage4Stream = $Part1Session.Session.CreateShellStream("SSH-P1-ST4", 0, 0, 0, 0, 2048)

$Part2Stage1Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST1", 0, 0, 0, 0, 2048)
$Part2Stage2Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST2", 0, 0, 0, 0, 2048)
$Part2Stage3Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST3", 0, 0, 0, 0, 2048)
$Part2Stage4Stream = $Part2Session.Session.CreateShellStream("SSH-P2-ST4", 0, 0, 0, 0, 2048)

$LogStream = $Part1Session.Session.CreateShellStream("SSH-LOG-STREAM", 0, 0, 0, 0, 2048)

$Part1Stage1Stream, $Part1Stage2Stream, $Part1Stage3Stream, $Part1Stage4Stream, $LogStream, $Part2Stage1Stream, $Part2Stage2Stream, $Part2Stage3Stream, $Part2Stage4Stream | ForEach-Object {
    if ($null -eq $_) {
        Write-Error "SSH Streams incomplete. Closing SSH Session and exiting script..."
        Remove-SSHSession -SSHSession $Part1Session | Out-Null
        Remove-SSHSession -SSHSession $Part2Session | Out-Null
        exit
    }
}

<# Stage 0: Iterating through the folderstructure.
Target:
Contents of every folders, subfolders and putting the results into a logfile.

Tools:
Powershell: Using SSH to get all the current contents of the Fortigate.
Using 3 functions and iterating through generated hashtables 3 times would get us to our folder-structure 'dead-end'.

All contents will be put into a logfile which we will use multiple times in this script.
MAKE SURE YOU SET THE LOGFILE STRING!!!!

FortiOS: Using fortinet system control (fnsysctl) ls-cmdlet with -la parameter for showing hidden files and folders.
#>

$Logfile = "PATH\Fortigate\COATHANGER\Fortigate-CVE-2022-42475_Coathanger-$(Get-Date -Format "MM/dd/yyyy-HH-mm").log"
if ($null -eq $Logfile) { Write-Error "No Logging patch set. Exiting script..."; exit }

function SearchForDirs($SearchList) {
    # Splitting the SSH Output string to select the last entry, which contains the name of the file/folder
    $SearchList | ForEach-Object {
        $LineArray = @($_ -split " " | Where-Object { $_ -ne "" })
        # Filtering directories and adding them to the hashtable for later scanning
        if ($LineArray[0] -match "dr") {
            $LineArrayFilteredDirectory = "/" + $LineArray[$LineArray.Count - 1]
            if ($LineArrayFilteredDirectory -notin @("/.", "/..")) { $LineArrayFilteredDirectory }
        }
    }
}

function GenerateRootArray {
    # Using the SearchForDirs to look for directories and putting the results-array into the $DirectoryHashtable
    $Stage0RootCommand = "fnsysctl ls -la /"
    $Part0Output = Invoke-SSHStreamShellCommand -ShellStream $LogStream -Command $Stage0RootCommand
    Set-Content $Logfile -Value $Stage0RootCommand
    $Part0Output >> $Logfile
    # Generating a list of contents, formatting it and creating an array to put into the hashtable
    $DirectoryHashtable."/" = SearchForDirs -SearchList $Part0Output
}

function GenerateDirArray ($CurrentDirToAnalyze) {
    $Stage0DirCommand = "fnsysctl ls -la " + $CurrentDirToAnalyze
    $Part0DirArrayOutput = Invoke-SSHStreamShellCommand -ShellStream $LogStream -Command $Stage0DirCommand
    $Stage0DirCommand >> $Logfile
    $Part0DirArrayOutput >> $Logfile
    # Generating a list of contents, formatting it and creating an array to put into the hashtable
    SearchForDirs -SearchList $Part0DirArrayOutput
}

Write-Host "Generating the initial Root Directory Overview" -ForegroundColor Green
GenerateRootArray

# Hashtable run using Root Array Directory Hashtable
$DirectoryHashtableKeyLoop = $DirectoryHashtable.Keys
$DirectoryHashtableTarget1 = @{}

foreach ($HashKey in $DirectoryHashtableKeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtable.$HashKey) {
        if ($null -ne $Directory) {
            Write-Host "Scanning subdirectory $($Directory)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget1.$Directory = GenerateDirArray -CurrentDirToAnalyze $Directory
        }
    }
}


# Hashtable second run using previous target table $DirectoryHashtableTarget1
$DirectoryHashtableTarget1KeyLoop = $DirectoryHashtableTarget1.Keys
$DirectoryHashtableTarget2 = @{}

foreach ($HashKey in $DirectoryHashtableTarget1KeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtableTarget1.$HashKey) {
        if ($null -ne $Directory) {
            $SubDir = $HashKey + $Directory
            Write-Host "Scanning subdirectory $($SubDir)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget2.$Directory = GenerateDirArray -CurrentDirToAnalyze $SubDir
        }
    }
}

# Hashtable third run using previous target table $DirectoryHashtableTarget2
$DirectoryHashtableTarget2KeyLoop = $DirectoryHashtableTarget2.Keys
$DirectoryHashtableTarget3 = @{}

foreach ($HashKey in $DirectoryHashtableTarget2KeyLoop) {
    Write-Host "Scanning from main directory $($HashKey)" -ForegroundColor Green
    foreach ($Directory in $DirectoryHashtableTarget3.$HashKey) {
        if ($null -ne $Directory) {
            $SubDir = $HashKey + $Directory
            Write-Host "Scanning subdirectory $($SubDir)" -ForegroundColor DarkMagenta
            $DirectoryHashtableTarget3.$Directory = GenerateDirArray -CurrentDirToAnalyze $SubDir
        }
    }
}

Write-Host "`nDone scanning the filesystem. File created at " -ForegroundColor Green
Write-Host $Logfile -ForegroundColor Green

##### Part 1: CVE-2022-42475 sslvpn heap-based buffer overflow IoC's

<# Stage 1: Scanning systemlogs for application crashes
Targets:
Logdesc="Application crashed" and msg="[...] application: sslvpnd,[...], Signal 11 received, Backtrace: [...]“

Tools:
FortiOS: Display logs in CLI when there's a match in criteria.

execute log filter category 1
execute log filter field logdesc 'Application crashed'
execute log filter field msg '*application: sslvpnd*'
execute log display
#>

Write-Host `n"Stage 1: Scanning systemlogs for application crashes" -ForegroundColor Yellow
"Part 1 Stage 1: Scanning systemlogs for application crashes">>$Logfile
Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log filter category 1" | Out-Null
Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log filter field logdesc 'Application crashed'" | Out-Null
Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log filter field msg '*application: sslvpnd*'" | Out-Null
$Part1Stage1Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stage1Stream -Command "execute log display"
$Part1Stage1Output >> $Logfile

if (($Part1Stage1Output | Where-Object { $_ -ne "" }) -match "0 logs returned") {
    Write-Host "No logs found in system log that matched the criteria!" -ForegroundColor Green
    "No logs found in system log that matched the criteria!">>$Logfile 
}
else {
    Write-Host "Well, we've found something, let's check it out." -ForegroundColor Yellow
    "Well, we've found something, let's check it out.">>$Logfile
    $Part1Stage1Output 
}

<# Stage 2: Scanning of the crash debug logfiles
Targets:
Look for application sslvpnd crashes

Tools:
FortiOS: Display crashlog in CLI and analyse output with Powershell.

diagnose debug crashlog read
#>

Write-Host `n"Stage 2: Scanning of the crash debug logfiles" -ForegroundColor Yellow
"Part 1 Stage 2: Scanning of the crash debug logfiles">>$Logfile
$Part1Stage2Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stage2Stream -Command "diagnose debug crashlog read"
$CrashLogEntries = @("application sslvpnd", "signal 11 (Segmentation fault) received")
$Part1Stage2MatchingLines = $Part1Stage2Output | Select-String -SimpleMatch -List $CrashLogEntries
$Part1Stage2MatchingLines>>$Logfile
$Part1Stage2MatchingLines

<# Stage 3: Scan for Suspicious filesystem entries
Targets:
https://community.fortinet.com/t5/FortiGate/Technical-Tip-Critical-vulnerability-Protect-against-heap-based/ta-p/239420
Dir:/data/lib 
    /data/lib/libips.bak
    /data/lib/libgif.so
    /data/lib/libiptcp.so
    /data/lib/libipudp.so
    /data/lib/libjepg.so
Dir:/var
    /var/.sslvpnconfigbk
Dir:/data/etc
    /data/etc/wxd.conf
Dir:/
    /flash

Tools:
FortiOS: Using the $LogFile we've made earlier to collect (known) suspicious files.
Above are known file-locations, but using $LogFile we are broadening our location scope to everywhere.
#>

Write-Host `n"Stage 3: Scan for Suspicious filesystem entries" -ForegroundColor Yellow
"Part 1 Stage 3: Scan for Suspicious filesystem entries">>$Logfile
$Part1Stage3MatchingFilenames = @("libips.bak", "libgif.so", "libiptcp.so", "libipudp.so", "libjepg.so", ".sslvpnconfigbk", "wxd.conf")
$Part1Stage3MatchingLines = Get-Content $Logfile | Select-String -SimpleMatch -List $Part1Stage3MatchingFilenames

if ($null -eq $Part1Stage3MatchingLines) {
    Write-Host "No suspicious files found!" -ForegroundColor Green
    "No suspicious files found!">>$Logfile
}
else {
    Write-Host "We've found something, let's check it out!" -ForegroundColor Yellow
    "We've found something, let's check it out!">>$Logfile
    $Part1Stage3MatchingLines>>$Logfile
    $Part1Stage3MatchingLines
}

<# Stage 4: Find malicious connections FROM the Fortigate
Targets:
https://www.fortinet.com/blog/psirt-blogs/analysis-of-fg-ir-22-398-fortios-heap-based-buffer-overflow-in-sslvpnd
IP/Domains
High Confidence
188.34.130.40       (port 444 observed)
103.131.189.143     (ports 30080,30081,30443,20443 observed)
193.36.119.61       (ports 8443,444 observed)
172.247.168.153     (port 8033 observed)
139.180.184.197
66.42.91.32
158.247.221.101
107.148.27.117
139.180.128.142
155.138.224.122
185.174.136.20
139.180.184.197
66.42.91.32
158.247.221.101
107.148.27.117
139.180.128.142
155.138.224.122
185.174.136.20
45.86.229.220
45.86.231.71
139.99.35.116
139.99.37.119
194.62.42.105
45.86.231.71
45.86.229.220
185.250.149.32
137.175.30.138
146.70.157.133

Older Actor IPs
156.251.162.76
156.251.163.122
156.251.163.19
156.251.162.111

Tools:
FortiOS: Use the Fortigate equivalant of netstat: diagnose sys tcpsock
#>

Write-Host `n"Stage 4: Analyzing TCP Streams" -ForegroundColor Yellow
"Part 1 Stage 4: Analyzing TCP Streams">>$Logfile
$Part1Stage4Output = Invoke-SSHStreamShellCommand -ShellStream $Part1Stage4Stream -Command "diagnose sys tcpsock"
$Part1Stage4IPList = @("188.34.130.40", "103.131.189.143", "193.36.119.61", "172.247.168.153", "139.180.184.197", "66.42.91.32", "158.247.221.101", "107.148.27.117", "139.180.128.142", "155.138.224.122", "185.174.136.20", "139.180.184.197", "66.42.91.32", "158.247.221.101", "107.148.27.117", "139.180.128.142", "155.138.224.122", "185.174.136.20", "45.86.229.220", "45.86.231.71", "139.99.35.116", "139.99.37.119", "194.62.42.105", "45.86.231.71", "45.86.229.220", "185.250.149.32", "137.175.30.138", "146.70.157.133", "156.251.162.76", "156.251.163.122", "156.251.163.19", "156.251.162.111")
$Part1Stage4Output>>$Logfile
$Part1Stage4MatchingLines = $Part1Stage4Output | Select-String -SimpleMatch -List $Part1Stage4IPList

if ($null -eq $Part1Stage4MatchingLines) {
    Write-Host "No suspicious connections found!" -ForegroundColor Green
    "No suspicious connections found!">>$Logfile
}
else {
    Write-Host "We've found something!"`n
    "We've found something!">>$Logfile
    $Part1Stage4MatchingLines>>$Logfile
    $Part1Stage4MatchingLines
}


Write-Host `n"End of Part 1, closing SSH session." -ForegroundColor Yellow
"End of Part 1, closing SSH session.">>$Logfile
Remove-SSHSession -SSHSession $Part1Session | Out-Null

##### End of Part 1.

##### Part 2: COATHANGER-Malware

<# Stage 1: Scan for Suspicious filesystem entries
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear
Filenames comes from 3.3 and 'Appendix 1: YARA rules'

Dir:/data2
    /data2/.bd.key/authd
    /data2/.bd.key/httpsd
    /data2/.bd.key/newcli
    /data2/.bd.key/preload.so
    /data2/.bd.key/sh
Dir:/bin
    /bin/smartctl
    /data/bin/smartctl
Dir:/lib
    /lib/liblog.so
Dir:/etc
    /etc/ld.so.preload
Dir:/tmp
    /tmp/packfile

Files:
    authd
    httpsd
    newcli
    preload.so
    sh
    smartctl
    liblog.so
    ld.so.preload
    packfile

Tools:
FortiOS: Using the $LogFile we've made earlier to collect (known) suspicious files.
Above are known file-locations, but using $LogFile we are broadening our location scope to everywhere.
#>

Write-Host `n"Stage 1: Scan for Suspicious filesystem entries" -ForegroundColor Yellow
"Part 2 Stage 1: Scan for Suspicious filesystem entries">>$Logfile
@("authd", "httpsd", "newcli", "preload.so", "sh", "smartctl", "liblog.so", "ld.so.preload", "packfile")

$Part2Stage1MatchingFilenames = @("authd", "httpsd", "newcli", "preload.so", "smartctl", "liblog.so", "ld.so.preload", "packfile")
$Part2Stage1MatchingLines = Get-Content $Logfile | Select-String -SimpleMatch -List $Part2Stage1MatchingFilenames

if ($null -eq $Part2Stage1MatchingLines) {
    Write-Host "No suspicious files found!" -ForegroundColor Green
    "No suspicious files found!">>$Logfile
}
else {
    Write-Host "We've found something, let's check it out!" -ForegroundColor Yellow
    "We've found something, let's check it out!">>$Logfile; sleep 2;
    $Part2Stage1MatchingLines>>$Logfile
    $Part2Stage1MatchingLines
}



<# Stage 2: Find malicious connections FROM the Fortigate
Targets:
https://www.ncsc.nl/documenten/publicaties/2024/februari/6/mivd-aivd-advisory-coathanger-tlp-clear

There's no IP addresses list to look for that are suspicious.
We should look for processes that connect to external IP that are not trusted.
In the document it mentions httpsd, but these connections may vary in which process-name they tend to use.

Tools:
FortiOS: Use the Fortigate equivalant of netstat: diagnose sys tcpsock
#>

Write-Host `n"Stage 2: Analyzing TCP Streams" -ForegroundColor Yellow
"Part 2 Stage 2: Analyzing TCP Streams">>$Logfile
$Part2Stage2Output = Invoke-SSHStreamShellCommand -ShellStream $Part2Stage2Stream -Command "diagnose sys tcpsock"
$Part2Stage2Output>>$Logfile

Write-Host "Please look for suspicious external connections:"; $Part2Stage2Output

<# Stage 3: Analyse the processes for anomalies, with extra attention to PID's captured in Stage 2
Targets:

Tools:

Get all running processes:
fnsysctl ps

Get all PID's of a specific processname:
diagnose sys process pidof httpsd

#>
